# ai-cmd v0.2.0 开发日志

## 项目概述

ai-cmd 是一个将自然语言转换为 shell 命令的 CLI 工具。v0.2.0 版本的核心目标是添加智能缓存机制，通过用户反馈学习来减少 API 调用成本。

## 方案演进历程

### 初始需求分析

**核心问题**：
1. 如何获得用户反馈来判断命令的正确性？
2. SQLite 本地缓存是否会增加安装复杂度？
3. 如何实现模糊查询匹配相似的历史查询？

### 第一轮方案设计

**最初的缓存方案**：
- 使用 SQLite 存储查询-命令对
- 实现 TF-IDF 文本相似度算法
- 通过 `--feedback good/bad` 收集用户反馈
- 基于置信度阈值决定是否使用缓存

**存在的问题**：
- 用户需要主动提供反馈，操作繁琐
- 反馈与查询的匹配可能不准确
- 打断了原有的简洁工作流

### 突破性方案设计

**用户创意**：通过"复制到剪贴板确认"作为反馈机制

**核心思路**：
1. 配置驱动：用户可选择开启交互模式
2. 不自动复制到剪贴板，而是询问用户 Y/N
3. Y = 正反馈（权重较低），N = 负反馈
4. 多次相同问题的正反馈累积，达到阈值后自动使用缓存
5. 负反馈会显著降低置信度

## 技术方案详解

### 1. 配置系统设计

```env
# 新增环境变量配置
AI_CMD_INTERACTIVE_MODE=false         # 默认关闭，保持向后兼容
AI_CMD_CONFIDENCE_THRESHOLD=0.8       # 使用缓存的置信度阈值
AI_CMD_AUTO_COPY_THRESHOLD=0.9        # 自动复制的置信度阈值
AI_CMD_POSITIVE_WEIGHT=0.2            # 确认的权重增量
AI_CMD_NEGATIVE_WEIGHT=0.5            # 拒绝的权重减量
AI_CMD_SIMILARITY_THRESHOLD=0.7       # 查询相似度阈值
```

**设计原则**：
- 默认关闭交互模式，保持向后兼容
- 所有参数可配置，适应不同用户需求
- 提供合理的默认值

### 2. 置信度算法设计

**数学模型**：
```python
def calculate_confidence(feedback_history):
    total_weight = 0
    current_time = time.time()
    
    for feedback in feedback_history:
        # 时间衰减：30天后权重减半
        age_days = (current_time - feedback.timestamp) / (24 * 3600)
        decay_factor = max(0.5, 1 - age_days / 30)
        
        if feedback.action == 'confirmed':
            total_weight += 0.2 * decay_factor
        elif feedback.action == 'rejected':
            total_weight -= 0.5 * decay_factor
    
    # 使用 sigmoid 函数将权重转换为 0-1 置信度
    confidence = 1 / (1 + math.exp(-total_weight * 2))
    return max(0.0, min(1.0, confidence))
```

**权重设计逻辑**：
- 正反馈权重较低（0.2）：需要多次确认才能建立信任
- 负反馈权重较高（0.5）：一次拒绝就能显著降低置信度
- 时间衰减机制：避免过时的反馈影响当前决策

**置信度增长验证**：
- 从 0 开始，需要 4 次确认达到 0.8 阈值
- 一次拒绝后，需要 2.5 次确认才能恢复
- 数学模型经过验证，既不过于敏感也不过于迟钝

### 3. 查询相似度匹配

**同义词映射**：
```python
synonyms = {
    'list': ['show', 'display', 'ls', 'view', '列出', '显示'],
    'create': ['make', 'new', 'mkdir', 'touch', '创建', '新建'],
    'delete': ['remove', 'rm', 'del', 'unlink', '删除', '移除'],
    'find': ['search', 'locate', 'grep', '查找', '搜索']
}
```

**相似度算法**：
- Jaccard 相似度（词集交集/并集）
- 最长公共子序列（考虑词序）
- 综合相似度 = Jaccard * 0.7 + LCS * 0.3

**查询标准化**：
- 转小写、去标点
- 同义词替换
- 支持中英文混合查询

### 4. 用户交互流程

**完整工作流**：

```
用户输入查询
    ↓
检查交互模式配置
    ↓
[关闭] → 原有行为（API + 自动复制）
    ↓
[开启] → 查找相似缓存查询
    ↓
计算最佳匹配的置信度
    ↓
[置信度 >= 0.9] → 直接使用缓存 + 自动复制
    ↓
[置信度 >= 0.8] → 使用缓存 + 询问确认
    ↓
[置信度 < 0.8] → 调用 API + 询问确认
    ↓
用户确认 [Y/N]
    ↓
更新置信度记录
```

**交互示例**：

场景1 - 首次查询：
```bash
$ aicmd "list files"
> ls -la  [API]
Copy to clipboard? [Y/n]: y
✓ Copied to clipboard
# 置信度: 0.0 → 0.2
```

场景2 - 置信度达到阈值：
```bash
$ aicmd "show files"  # 相似查询
> ls -la  [cached (confidence: 0.85)]
✓ Copied to clipboard  # 自动复制
```

场景3 - 用户拒绝：
```bash
$ aicmd "list all files"
> ls -la  [cached (confidence: 0.75)]
Copy to clipboard? [Y/n]: n
✗ Not copied
# 置信度: 0.75 → 0.25
```

### 5. 数据库设计

**扩展的缓存表结构**：
```sql
CREATE TABLE enhanced_cache (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    query TEXT NOT NULL,
    query_hash TEXT NOT NULL,           -- 标准化查询哈希
    command TEXT NOT NULL,
    confidence_score REAL DEFAULT 0.0,
    confirmation_count INTEGER DEFAULT 0,
    rejection_count INTEGER DEFAULT 0,
    last_used DATETIME DEFAULT CURRENT_TIMESTAMP,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    os_type TEXT,
    shell_type TEXT,
    INDEX idx_query_hash (query_hash),
    INDEX idx_confidence (confidence_score DESC)
);

CREATE TABLE feedback_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    query_hash TEXT NOT NULL,
    command TEXT NOT NULL,
    action TEXT NOT NULL,              -- 'confirmed', 'rejected'
    weight_factor REAL DEFAULT 1.0,
    timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_query_hash_time (query_hash, timestamp DESC)
);
```

### 6. SQLite 复杂度分析

**技术事实澄清**：
- SQLite 是 Python 标准库的一部分（sqlite3 模块）
- 无需额外安装、配置或服务进程
- 跨平台兼容（Windows/macOS/Linux）
- 单文件存储，易于管理和备份

**安全实施保障**：
- 完善的错误处理和降级机制
- 缓存失败时自动回退到 API 调用
- 支持自定义缓存路径和配置
- WAL 模式提高并发性能

**复杂度对比**：
- 传统数据库：需要安装、配置、维护服务
- SQLite：零配置，开箱即用
- 结论：完全没有安装复杂度问题

## 方案优势分析

### 1. 用户体验优势

**无缝集成**：
- 保持原有简洁工作流
- 配置驱动，用户可选择
- 高置信度时自动复制，不打断流程

**智能学习**：
- 通过自然的用户行为收集反馈
- 渐进式信任建立机制
- 支持相似查询的知识迁移

### 2. 技术架构优势

**零外部依赖**：
- 仅使用 Python 标准库
- 保持单文件架构原则
- 跨平台兼容性强

**优雅降级**：
- 任何组件失败都不影响核心功能
- 提供多层次的配置选项
- 支持完全禁用缓存功能

### 3. 可扩展性优势

**模块化设计**：
- 清晰的类职责划分
- 易于测试和维护
- 支持未来功能扩展

**配置灵活性**：
- 所有参数可调
- 支持不同用户场景
- 便于性能调优

## 潜在风险与缓解

### 1. 用户体验风险

**风险**：交互确认可能打断工作流
**缓解**：
- 默认关闭交互模式
- 高置信度时自动复制
- 提供快速禁用选项

### 2. 技术实现风险

**风险**：相似度算法可能不准确
**缓解**：
- 多层次相似度算法
- 可配置的相似度阈值
- 支持用户反馈调整

### 3. 数据安全风险

**风险**：缓存可能包含敏感信息
**缓解**：
- 敏感词检测和过滤
- 支持缓存清理功能
- 本地存储，用户控制

## 性能预期

### 1. 缓存命中率

**预期指标**：
- 新用户：20-30%（学习阶段）
- 活跃用户：60-80%（稳定阶段）
- API 调用减少：50-70%

### 2. 响应时间

**预期性能**：
- 缓存查询：< 10ms
- 相似度计算：< 50ms
- 用户交互：< 3s（等待用户输入）

### 3. 存储占用

**预期指标**：
- 1000 条缓存：< 1MB
- 数据库文件增长：线性可控
- 支持定期清理策略

## 后续迭代规划

### v0.2.2 - 智能优化

**计划功能**：
- 模式检测（撤销、修正）
- 自适应阈值调整
- 高级统计分析

### v0.2.2 - 用户体验

**计划功能**：
- 快速反馈机制
- 详细的使用统计
- 导出导入功能

### v0.3.0 - 高级特性

**计划功能**：
- 上下文感知缓存
- 多语言模型支持
- 云同步功能（可选）

## 总结

v0.2.0 的方案设计充分体现了以下原则：

1. **用户至上**：通过创新的反馈机制，既收集了用户意图，又保持了工具的简洁性
2. **技术务实**：选择了最适合的技术栈，避免了过度工程化
3. **渐进演进**：通过配置驱动的方式，确保了向后兼容性
4. **质量优先**：设计了完善的错误处理和性能优化机制

这个方案不仅解决了原有的技术挑战，更重要的是通过用户的创意想法，找到了一个既优雅又实用的解决方案。通过"复制确认"这个自然的用户行为，我们成功地将反馈收集无缝集成到了用户的工作流中。

## 最终任务计划

基于深度思考和风险分析，制定了以下 8 个核心任务的 MVP 版本实施计划：

### Phase 0: 基础设施建设

#### Task 1: 配置管理系统和环境变量处理
- **目标**: 实现 ConfigManager 类，支持所有缓存相关配置项
- **重点**: 异常安全性，配置错误不影响核心功能
- **验收**: 所有配置项正确读取，提供合理默认值
- **时间**: 2-3 天

#### Task 2: 数据库 Schema 设计和安全初始化  
- **目标**: SQLite 数据库结构设计和安全初始化
- **重点**: 跨平台兼容，异常降级机制
- **验收**: 数据库正确创建，异常时优雅降级
- **时间**: 3-4 天

#### Task 3: 基础缓存管理器和 CRUD 操作
- **目标**: CacheManager 类，提供基础增删改查
- **重点**: 数据一致性和事务安全
- **验收**: 缓存操作正确，支持并发访问
- **时间**: 3-4 天

#### Task 4: 错误处理和优雅降级机制
- **目标**: 全面的异常处理，确保系统稳定性
- **重点**: 任何缓存异常都不影响原有功能
- **验收**: 各种异常下程序不崩溃，自动降级
- **时间**: 2-3 天

### Phase 1: 核心算法实现

#### Task 5: 简单查询匹配算法
- **目标**: 基础的查询匹配，支持精确和相似匹配
- **重点**: 稳定性和正确性，支持中英文
- **验收**: 查询处理正确，相似度计算合理
- **时间**: 3-4 天

#### Task 6: 基础置信度计算
- **目标**: 简化的线性置信度模型
- **重点**: 算法可理解性和稳定性
- **验收**: 置信度在 0-1 范围，反馈机制正确
- **时间**: 2-3 天

### Phase 2: 用户交互

#### Task 7: 用户交互界面
- **目标**: Y/N 确认界面，支持超时和异常处理
- **重点**: 用户体验，不能阻塞工作流
- **验收**: 各种输入正确处理，界面清晰友好
- **时间**: 2-3 天

### Phase 3: 系统集成

#### Task 8: 主流程集成
- **目标**: 集成所有组件到主流程
- **重点**: 向后兼容性，无缝集成
- **验收**: 新功能不影响原有行为，体验流畅
- **时间**: 4-5 天

## 总体时间估算

- **总工作量**: 21-29 天（约 3-4 周）
- **关键路径**: Task1 → Task2 → Task3 → Task4 → Task8
- **并行任务**: Task5, Task6, Task7 可以与前期任务并行开发
- **风险缓冲**: 每个阶段预留 20% 时间缓冲

## 质量保证策略

### 测试策略
1. **单元测试**: 每个组件独立测试，覆盖率 >80%
2. **集成测试**: 组件间协作测试
3. **用户体验测试**: 交互流程测试
4. **降级测试**: 异常情况处理测试

### 验收标准
1. **功能正确性**: 核心逻辑按设计工作
2. **异常安全性**: 异常不影响主功能
3. **性能要求**: 响应时间 <100ms
4. **用户体验**: 交互简洁友好
5. **向后兼容**: 原有用法完全不变

## 风险缓解措施

1. **技术风险**: 每个组件都有独立的降级机制
2. **集成风险**: 分阶段集成，逐步验证
3. **用户体验风险**: 默认关闭新功能，用户主动开启
4. **性能风险**: 优先保证功能正确性，后续优化性能

## 下一步行动

1. **立即开始**: Task 1 (配置管理系统)
2. **并行准备**: Task 5 (查询匹配算法) 的算法设计
3. **环境准备**: 开发环境配置和测试框架搭建
4. **文档准备**: 用户指南和 API 文档框架
